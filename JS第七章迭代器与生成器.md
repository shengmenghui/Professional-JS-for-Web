# 第七章 迭代器与生成器
## 7.1 理解迭代
计数循环就是最简单的一种迭代，循环时迭代机制的基础，因为他可以指定迭代的次数，以及每次迭代要执行什么操作。每次迭代循环都会在下一次迭代开始之前完成，而每次迭代的顺序是事先定义好的。

迭代会在一个有序集合上进行。（“有序”可以理解为集合中所有项都可以按照既定的顺序被遍历到，特别是开始和结束项有明确的定义。）数组是 JavaScript 中有序集合的最典型例子。因为数组有已知的长度，且数组每一项都可以通过索引获取，所以整个数组可以通过递增索引来遍历。由于如下原因，通过这种循环来执行例程并不理想
* 迭代之前需要事先知道如何使用数据结构
* 遍历顺序并不是数据结构固有的

ES5 新增了 Array.prototype.forEach()方法，该方法解决了单独记录索引和通过数组对象取得值的问题，但没有办法标识迭代何时终止。这个方法只适用于数组，而且回调结构也比较笨拙
## 7.2 迭代器模式
迭代器模式提供了一种方法顺序访问一个聚合中的各种元素，而又不暴露该对象的内部表示。
### 7.2.1 可迭代协议
实现Iterable 接口需要两种能力：支持迭代的自我识别能力和创建实现Iterator 接口的对象的能力。这意味着必须暴露一个属性作为“默认迭代器”，而且这个属性必须使用特殊的 Symbol.iterator 作为键。这个默认迭代器属性必须引用一个迭代器工厂函数，调用这个工厂函数必须返回一个新迭代器。很多内置类型都有实现：
* 字符串
* 数组
* 映射
* 集合
* argument 对象
* NodeList 等DOM集合类型

实际写代码过程中，不需要显示调用这个工厂函数来生成迭代器。实现可迭代协议的所有类型都会自动兼容接收可迭代对象的任何语言特性：
* for-of 循环
* 数组解构
* 扩展操作符
* Array.form()
* 创建集合
* 创建映射
* Promise.all() 接收由期约组成的可迭代对象
* Promise.race() 接收由期约组成的可迭代对象
* yield*操作符，在生成器中使用
  
如果对此昂原型链上的父类实现了Iterable接口，那这个对象也就实现了这个接口
### 7.2.2 迭代器协议
迭代器 API 使用 next()方法在可迭代对象中遍历数据。每次成功调用 next()，都会返回一个 IteratorResult 对象，其中包含迭代器返回的下一个值。next()方法返回的迭代器对象 IteratorResult 包含两个属性：done 和 value。done 是一个布尔值，表示是否还可以再次调用 next()取得下一个值；value 包含可迭代对象的下一个值（done 为false），或者 undefined（done 为 true）。done: true 状态称为“耗尽”：

    // 可迭代对象
    let arr = ['foo', 'bar']; 
    // 迭代器工厂函数
    console.log(arr[Symbol.iterator]); // f values() { [native code] } 
    // 迭代器7.2 迭代器模式
    let iter = arr[Symbol.iterator](); 
    console.log(iter); // ArrayIterator {} 
    // 执行迭代
    console.log(iter.next()); // { done: false, value: 'foo' } 
    console.log(iter.next()); // { done: false, value: 'bar' } 
    console.log(iter.next()); // { done: true, value: undefined } 

通过创建迭代器并调用 next()方法按顺序迭代了数组，直至不再产生新值。迭代器并不知道怎么从可迭代对象中取得下一个值，也不知道可迭代对象有多大。只要迭代器到达 done: true 状态，后续调用 next()就一直返回同样的值了。

每个迭代器都表示对可迭代对象的一次性有序遍历。不同迭代器的实例相互之间没有联系，只会独立地遍历可迭代对象。

迭代器并不与可迭代对象某个时刻的快照绑定，而仅仅是使用游标来记录遍历可迭代对象的历程。如果可迭代对象在迭代期间被修改了，那么迭代器也会反映相应的变化。
### 7.2.3 自定义迭代器
与 Iterable 接口类似，任何实现 Iterator 接口的对象都可以作为迭代器使用。
## 7.3 生成器
能在一个函数块内暂停和恢复代码执行
### 7.3.1 生成器基础
函数名称前面加一个星号（*）表示它是一个生成器。但箭头函数不能用来定义生成器函数。标识生成器函数的星号不受两侧空格的影响。

调用生成器函数会产生一个生成器对象。生成器对象一开始处于暂停执行（suspended）的状态。与迭代器相似，生成器对象也实现了 Iterator 接口，因此具有 next()方法。调用这个方法会让生成器开始或恢复执行。

next()方法的返回值类似于迭代器，有一个 done 属性和一个 value 属性。函数体为空的生成器函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态。value 属性是生成器函数的返回值，默认值为 undefined，可以通过生成器函数的返回值指定。生成器函数只会在初次调用 next()方法后开始执行。生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的。
### 7.3.2 通过yield中断执行
yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方。
### 7.3.3 生成器作为默认迭代器
因为生成器对象实现了 Iterable 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。
### 7.3.4 提前终止生成器
与迭代器类似，生成器也支持“可关闭”的概念。一个实现 Iterator 接口的对象一定有 next()方法，还有一个可选的 return()方法用于提前终止迭代器。
## 7.4 小结
迭代是一种所有编程语言中都可以看到的模式。ECMAScript 6 正式支持迭代模式并引入了两个新的语言特性：迭代器和生成器。

迭代器是一个可以由任意对象实现的接口，支持连续获取对象产出的每一个值。任何实现 Iterable接口的对象都有一个 Symbol.iterator 属性，这个属性引用默认迭代器。默认迭代器就像一个迭代器工厂，也就是一个函数，调用之后会产生一个实现 Iterator 接口的对象。

迭代器必须通过连续调用 next()方法才能连续取得值，这个方法返回一个 teratorObject。这个对象包含一个 done 属性和一个 value 属性。前者是一个布尔值，表示是否还有更多值可以访问；后者包含迭代器返回的当前值。这个接口可以通过手动反复调用 next()方法来消费，也可以通过原生消费者，比如 for-of 循环来自动消费。

生成器是一种特殊的函数，调用之后会返回一个生成器对象。生成器对象实现了 Iterable 接口，因此可用在任何消费可迭代对象的地方。生成器的独特之处在于支持 yield 关键字，这个关键字能够暂停执行生成器函数。使用 yield 关键字还可以通过 next()方法接收输入和产生输出。在加上星号之后，yield 关键字可以将跟在它后面的可迭代对象序列化为一连串值。